#세션 관리
웹 서버는 메모리가 없다. 웹 서버는 응답을 보낸 다음에는 클라이언트가 누구였는지 구분할 수 없다. 그러나 프로그램을 짜다보면 클라이언트와의 대화 내용을 기억해야할 필요가 있다.

##이전 대화를 기억하는 방법

1. 상태 유지 EJB를 사용하는 방법
서블릿을 상태유지 세션 빈의 클라이언트로 만든다. 요청이 들어오면, 상태 유지 빈을 찾아서 작업을 수행한다. 그러나 애플리케이션에 부하가 꽤 걸린다.

2. 데이터베이스를 사용하는 방법
호스팅 업체가 데이터베이스에 접근하도록 하면 가능하다. 그러나 런타임 성능에 영향을 미친다. 가벼운 대화에에 있어서는 지나친 과잉 스펙이다.

3. HttpSession을 사용하는 방법
한 클라이언트의 전체 세션 간 정보를 유지할 때 사용한다. 사실 위의 두 방법을 사용한다고 하더라도 HttpSession 객체는 사용해야한다.

##세션의 작동 방식
* 같은 클라이언트가 여러 번 물었을 때
	* 똑같은 클라이언트
	* 똑같은 서블릿
	* 서로 다른 요청
	* 서로 다른 스레드
	* 똑같은 세션

* 다른 클라이언트가 물어왔을 때
	* 서로 다른 클라이언트
	* 똑같은 서블릿
	* 서로 다른 요청
	* 서로 다른 스레드
	* 서로 다른 세션

##컨테이너는 클라이언트를 어떻게 구분하는가?
HTTP 프로토콜은 무상태(stateless) 연결이다. 연결이라 함은 한 번의 요청과 응답을 위해 존재한다고 할 수 있다.
지속적인 연결이 아니기때문에, 클라이언트가 두 번째 요청을 보내도 컨테이너는 같은 클라이언트라고 인식할 줄 모른다.

###클라이언트는 유일한 세션 ID가 필요하다.
클라이언트가 제일 처음 요청을 보낼 때, 그 세션에 ID를 붙이는 방법을 사용하면 된다. 다음 클라이언트가 요청을 보낼 때 이 세션 ID를 보내서 컨테이너가 세션을 찾을 수 있도록 한다.
클라이언트와 컨테이너가 세션 ID 정보를 공유하는 방법은 **쿠키**이다.
그리고 이 쿠키에 관련된 정보의 처리는 컨테이너가 거의 다 한다.

사용자는
* 새로운 HttpSession 객체를 직접 만들 필요가 없다.
* 세션 ID를 설정할 필요가 없다.
* 새 쿠키 객체를 만들 필요도 없다.
* 세션 ID와 쿠키를 연결할 필요도 없다.

###세션이 새 것인지 기존의 것인지 판단하는 방법
'HttpSession.isNew()' 메소드를 사용하고, 이미 만들어져있는 세션을 원할때는 'request.getSession(false)'를 사용한다. 만약 기존의 세션이 없다면 request.getSession(false)는 null을 리턴한다.

###쿠키를 사용하지 않고 세션이 작동하도록 하는 방법 : URL 재작성
'jsessionid'를 링크 뒤에 붙여서 URL 뒤에 세션 ID가 붙도록 한다.
URL 재작성은 자동으로 일어나기 때문에 정적인 페이지나 JSP에서 재작성 하기 위해서는 동적으로 페이지를 생성하도록 바꿔줄 필요가 있다.

##세션을 제거하자
###세션이 종료되는 세가지 이유
1. 시간이 다 되어서(타임 아웃)
2. 개발자가 세션 객체에 invalidate() 메소드를 실행하는 경우
3. 애플리케이션이 다운되는 경우

* DD에서 세션 타임아웃 설정하기
```
<session-config>
	<session-timeout>15</session-timeout> //15분동안 대기
</session-config)
```

* 특정 세션만 타임아웃 설정하기  
`session.setMaxInactiveInterval(20*60); //20분동안 대기`

###쿠키의 다른 용도
쿠키는 그냥 서버와 클라이언트 간에 교환하는 조그마한 데이터 그 이상은 아니다.
따라서 세션을 지원하는 것 뿐만 아니라 다른 곳에 사용해도 된다.

###URL 재작성은 요청으로 내려보낼 HTML에 있는 모든 URL 끝에 세션 ID를 추가하는 방식이다.
###URL 재작성은 쿠키 기능이 제거된 클라이언트를 위해 자동적으로 작동한다. 그러나 개발자가 URL을 명시적으로 인코딩해야한다.
###정적인 페이지에 URL 재작성을 구현할 방법은 없다. 세션을 사용하고 싶다면 동적인 페이지를 사용해야 한다.
