# 조금 더 깊이 들어가보기
## 컨테이너란?
### 서블릿에는 main() 메소드가 없다.
### 서블릿은 컨테이너라는 자바 어플리케이션의 지배를 받는다.
* 웹 서버가 사용자로부터 요청을 받으면, 서블릿에게 바로 주지 않고 컨테이너에게 요청을 넘겨준다.
* 컨테이너는 HTTP Request와 HTTP Response 객체를 만들어 서블릿의 doGet()이나 doPost()를 호출한다.


##컨테이너가 주는 혜택
### 통신 지원
* 컨테이너는 API를 통해 서버소켓을 만들고, 특정 포트에 리스닝하고, 스트림을 생성해준다.
* 개발자는 비즈니스 로직에만 집중하면 된다.

### 생명주기 관리
* 컨테이너는 서블릿 클래스를 인스턴스화 하고, 초기화 메소드를 호출하고, 서블릿 메소드를 호출한다.
* 서블릿의 생명이 끝나면 가비지 컬렉션도 해준다.

### 멀티스레딩 지원
* 컨테이너는 요청이 들어올때 마다 새로운 스레드를 만든다.
* 개발자가 멀티스레드의 생성 및 운영에 대하여 신경쓸 필요가 없다.

### 선언적인 보안 관리
* 보안에 관련된 내용을 하드코딩 할 필요가 없다.
* 보안에 대한 수정은 XML 배포 서술자에 기록하면 된다.

### JSP 지원


## 컨테이너가 요청을 다루는 순서
1. 사용자가 서블릿에 대한 링크를 클릭한다.
2. 컨테이너는 요청을 확인하고 HttpServletResponse와 HttpServletRequest 객체를 생성한다.
3. URL을 분석하여 어떤 서블릿의 요청인지 알아내고 스레드를 생성하여 앞서 생성한 객체를 인자로 넘긴다.
4. 컨테이너는 service() 메소드를 호출한다. (doGet()과 doPost() 중 하나)
5. 서블릿 메소드는 동적인 페이지를 생성하고, Response 객체에 실어 보낸다.
6. 스레드 작업이 끝나면, HTTP Response로 전환하여 클라이언트에 보낸다.
7. 생성했던 객체를 소멸시킨다.


## 컨테이너가 서블릿을 찾는 방법
### 하나의 서블릿은 세개의 이름을 갖는다.
1. 클라이언트가 알고 있는 URL
2. 배포자가 만든 내부적인 이름
3. 실제 파일명

### 서블릿이 가진 세개의 이름들을 서로 매핑한다.
* 이 작업은 배포 서술자(DD, Development Descriptor)라는 XML파일에서 이루어진다.
* <servlet>에는 내부 이름과 실제 파일명을 매핑한다.
* <servlet-mapping>에는 내부 이름과 URL을 매핑한다.
* DD는 서블릿 매핑 말고도 여러가지 기능을 가지고 있다.


## MVC 패턴
### MVC 패턴은 단순히 비즈니스 로직과 프리젠테이션 로직을 분리하는것 뿐만 아니라 두 로직이 별개로 존재할 수 있다는 것을 의미한다.

### MVC 패턴을 사용하는 이유
* 비즈니스 로직 자체가 한가지 인터페이스를 통해서만 접근된다고 단정할 수 없다.
* **스펙은 항상 변한다.**

### 서블릿에서의 MVC 패턴
* 뷰 = JSP
* 컨트롤러 = 서블릿
* 모델 = 자바 클래스
* 단순히 MVC를 나누었다고 완벽한 디자인이라고 할 수 없다.
* 중복되는 로직이 담긴 서블릿들을 관리할 방법이 필요하다. -> 후반부에 해결책 제시


## J2EE(현재 Java EE)의 구성
### J2EE는 스펙들에 대한 스펙, 즉 슈퍼 스펙이라고 할 수 있다.
* J2EE는 서블릿 2.4와 JSP 2.0 등과 같은 스펙들을 포함하고 있다.
* 이들은 모두 웹 컨테이너를 위한 것으로서, 이것 말고도 EJB 스펙도 있다.
* 웹 컨테이너 스펙과 EJB 스펙이 모두 있어야 J2EE라고 할 수 있다.


## 정리
### 컨테이너는 통신 지원, 생명주기 관리, 멀티스레딩 지원, 선언적인 보안관리, JSP 지원의 역할을 한다.
### 컨테이너는 Request와 Response 객체를 생성하여 이에 대한 참조를 통하여 서블릿으로부터 페이지를 받는다.
### 일반적으로 서블릿은 HttpServlet을 상속받아 doGet()이나 doPost() 메소드를 재정의하여 사용한다.
### 배포자가 서블릿 클래스와 URL을 매핑한다. 매핑하는 이름은 다를 수 있다.
