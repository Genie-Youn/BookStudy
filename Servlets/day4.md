#요청과 응답
##서블릿은 컨테이너가 관리한다.
1. 사용자가 서블릿에 대한 링크를 클릭한다.
2. 컨테이너는 요청된 Request가 서블릿이라는 것을 간파하고 HttpServletResponce, HttpServletRequest 두 개의 객체를 생성한다.
3. 접수한 요청의 URL을 분석하여 어떤 서블릿을 요청했는지 파악한다.(여기서 DD를 참조한다.) 그 다음 해당 서블릿 스레드를 생성하여 Request, Response 객체 참조를 넘긴다.
4. 컨테이너는 서블릿 service() 메소드를 호출한다. 브라우저에서 지정한 방식에 따라 doGet()과 doPost() 중 하나를 선택하여 호출한다. 호출할 때 전달받은 Request, Response 객체를 인자로 넘긴다.
5. 서블릿은 클라이언트에게 응답을 작성하기 위하여 Response 객체를 사용한다.
6. service() 메소드가 끝나면, 스레드를 소멸하거나 컨테이너가 관리하는 스레드 풀로 돌려보낸다.
7. 클라이언트가 서버로부터 응답을 받는다.

##서블릿의 상태
* 초기화 상태 : init() 메소드에 의해 얻어진다. init() 메소드는 서블릿의 일생 중 오직 한번만 호출되며 service() 메소드가 실행되기 전에 실행되어야 한다.
* 소멸 상태 : destroy() 메소드에 의해 자원들이 정리되는 상태. init() 메소드처럼 단 한번만 호출된다.
* 존재하지 않음 : 아직 생성되지 않았거나 소멸되어 존재하지 않는 상태.

##서블릿 일생의 3번의 중요한 순간
1. init() : 서블릿을 초기화한다. 재정의 할 수 있다.
2. service() : 요청을 처리한다. 재정의는 거의 하지 않는다.
3. doGet() 혹은 doPost() : 요청된 작업을 실행한다. 반드시 재정의 해야한다.

##클라이언트의 요청은 서로 다른 스레드에서 실행된다.
###컨테이너는 서블릿 하나에 대한 다수의 요청을 처리하기위하여 다수의 스레드를 실행한다. 그러나 인스턴스는 단 한개다.
스레드는 요청 당 하나씩 생성되며 클러스터링을 하면 하나의 JVM 당 하나의 서블릿이 실행된다.

##객체가 서블릿이 되는 순간
###생성자는 객체를 만드는 것이지 서블릿을 만드는 것은 아니다.
객체가 서블릿이 되려면 서블릿적인(servletness)것을 받아야한다.
객체가 서블릿이 된다는 것은 서블릿의 고유한 권한을 가진다는 것을 의미한다.

###서블릿적인 객체 두 가지
1. ServletConfig
* 서블릿 당 하나씩 가진다.
* ServletContext에 접근하기 위해 이 객체를 사용한다.
* 파라미터 값은 배포 서술자에서 설정 가능.

2. ServletContext
* 웹 애플리케이션 하나 당 하나씩 가진다.
* 웹 애플리케이션의 파라미터 정보를 얻기 위해 사용한다.
* 서버 정보를 파악하기 위해 사용한다.

##서블릿은 요청을 핸들링하기 위해 존재한다.
###GET과 POST 외에도 HTTP 메소드는 존재한다.
HTTP 메소드에는 GET, POST, HEAD, TRACE, PUT, DELETE, OPTIONS, CONNECT 등이 있으나 GET과 POST를 가장 많이 사용한다.

###GET과 POST의 차이점
* 표면적으로는 데이터의 양이 다르다. GET은 HEAD만 존재하며 POST는 몸체까지 있다.
* GET은 공개적이며 POST는 비공개적이다.
* GET은 멱등이다. 즉 여러번 요청을 보내도 실제 데이터에 영향을 주지 않는다. 반면에 POST는 멱등이 아니므로 한번 요청이 보내지면 데이터를 여러번 갱신 해버릴 수 있다.
* 디폴트 메소드는 GET이다. 따라서 POST 방식을 따로 코딩하지 않으면 GET 방식으로 넘어간다.

###파라미터 이외에 Request 객체에서 얻을 수 있는 정보
* 클라이언트 플랫폼 정보 및 브라우저 정보
`String client = request.getHeader("User-Agent");`
* Request에 관련된 쿠키
`Cookie[] cookies = request.getCookies();`
* 클라이언트의 세션 정보
`HttpSession session = request.getSession();`
* Request의 HTTP 메소드
`String theMethod = request.getMethod();`
* Request의 입력 스트림
`InputStream input = request.getInputStream();`

###Response 객체의 I/O
* 출력스트림으로 HTML만 보낼 수 있는 것이 아니다. 이외의 것(예: JAR)을 전송하려면 바이트로 읽어들여 스트림에 기록해야한다.
* 컨텐츠 타입은 브라우저에 내려보내는 것이 무엇인지를 알려준다. == MIME 타입
* 출력 방식에는 문자와 바이트가 있으며, 문자는 Writer, 스트림은 OutputStream을 사용한다.
* Response 헤더에는 값을 설정하거나 새로 추가할 수 있다.

###서블릿은 응답을 하지 않을 수도 있다.
* 서블릿은 요청의 방향을 바꿀 수 있다.
* 클라이언트에게 맡기는 것을 리다이렉트, 서버 내에서 처리하는 것을 요청 디스패치라고 한다.


##정리
###컨테이너는 서블릿을 로딩한다. 그 다음 디폴트 생성자를 호출하고, init() 메소드를 실행한다.
###init() 메소드는 일생 동안 단 한번 실행되며, ServletConfig 객체와 ServletContext 객체에 접근할 수 있다.
###서블릿은 일생 대부분을 요청에 대한 응답으로 service() 메소드를 실행하는데 보낸다.
###서블릿에 대한 클라이언트의 요청은 별개의 스레드에서 실행된다. 서블릿 인스턴스는 단 하나밖에 없다.
###init() 메소드는 재정의 '할수도' 있다. 그러나 doGet()과 doPost() 메소드는 '반드시' 재정의 해야한다.
###service() 메소드는 HTTP Request의 HTTP 메소드에 따라 doGet()을 호출할지 doPost()를 호출할지 결정한다.
###POST에는 몸체가 있다. GET은 몸체가 없다.
###GET은 멱등이다. POST는 멱등이 아니다.
###디폴트 HTML 폼은 GET이다.
###클라이언트로 데이터를 보내기 위해 Response 객체를 사용한다.
###Response 객체로 헤더 설정, 오류 전송, 쿠키 추가 등을 할 수 있다.
###실제 프로젝트에서는 HTML 응답을 보낼때 JSP를 사용하지만, 바이너리 파일을 전송하기 위해서 Response 스트림이 존재한다.
###요청에 응답하지 않고, 리다이렉트나 디스패치를 통하여 다른 곳으로 넘길 수 있다.
