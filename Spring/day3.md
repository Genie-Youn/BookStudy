#템플릿(1)
##템플릿
* 변경이 거의 일어나지 않으며, 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜 효과적으로 활용할 수 있도록 하는 방법
* JDBC try/catch/finally 코드를 가지고 설명을 하였다.

###전략패턴의 사용
* 컨텍스트 : 변하지 않는 로직, 문맥
* 전략 : 상황에 따라 변하는 로직, 인터페이스를 구현한다.
* 그리고 제 3자인 클라이언트는 자신이 사용할 전략을 선택해 컨텍스트에 전달한다. 의존성 주입

###전략과 클라이언트의 동거
* 한계1 : DAO 메소드마다 새로운 statementStrategy 클래스를 만들어야 한다.
* 한계2 : 전략에 전달할 부가적인 정보가 있을 경우, 오브젝트를 전달받는 생성자와 이를 저장해둘 인스턴스 변수를 만들어야 한다.

###로컬클래스
* 특정 메소드에서만 사용되는거라면 로컬클래스로 만들자!

###중첩클래스의 종류
* 다른 클래스 내부에 정의되는 클래스로
* 스태틱클래스 : 독립적으로 만들어질 수 있음
* 내부클래스 : 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있음, 멤버내부클래스, 로컬클래스, 익명내부클래스
* 멤버내부클래스 : 멤버필드처럼 오브젝트 레벨에서 정의
* 로컬클래스 : 메소드레벨에서 정의
* 익명내부클래스 : 이름을 갖지 않는다.

###다시 로컬클래스
* 로컬클래스는 자신이 선언된 곳의 정보에 접근할 수 있다.
* 즉 생성자를 통해 오브젝트를 전달할 필요가 없다.
* 다만 내부클래스에서 외부의 변수를 사용하기 위해선 외부변수를 항상  final로 선언해야 한다.

###익명내부클래스
* new 인터페이스이름() {클래스 본문} .. 개쩐다

##인터페이스를 사용하지 않고 밀접한 관계를 갖는 클래스에 DI를 적용하는 방법
###빈으로 등록하기
* 스프링 DI를 이용할수 있고 실제 의존관계가 설정파일에 명확하게 드러난다.
* 하지만 DI 원칙에 부합하지 않는 구체적인 클래스와의 관계가 설정에 직접 노출!

###코드를 통한 수동 DI
* 내부에서 은밀히 DI를 적용하고 외부에는 전략을 감출수 있다.
* 하지만 싱글톤을 못써 ㅜㅜ 부가적인 코드가 증가한다.

##템플릿과 콜백
* 복잡하지만 바뀌지 않는 일정한 작업흐름이 존재하고 그중 일부분만 자주 바꿔서 사용해야 하는 경우 적합한 구조인 전략패턴과
* 익명 내부클래스의 조합을 스프링에서는 템플릿/콜백 패턴이라고 부른다

###템플릿
* 어떤 목적을 위해 미리 만들어 둔 모양이 있는 틀

###콜백
* 실행되는것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트
* 파라미터로 전달되지만 값을 참조하기 위한 것이 아니라 특정 로직을 담은 메소드를 실행하기 위해 사용

###템플릿/콜백의 동작원리
* 여러개의 메소드를 가진 일반적인 인터페이스를 사용할 수 있는 전략패턴의 전략과 달리 템플릿/콜백 패턴의 콜백은 보통 단일 메소드 인터페이스를 사용한다.
* 템플릿의 작업흐름중 늑정기능을 위해 한 번 노출되는 경우가 일반적
* 클라이언트의 역할은 템플릿 안에서 실행될 로직을 담은 콜백 오브젝트를 만들고, 콜백이 참조할 정보를 제공한다.
* 만들어진 콜백은 클라이언트가 템플릿의 메소드를 호출할 때 파라미터로 사용된다.
* 템플릿은 정해진 작업흐름을 따라 작업을 진행하다가 내부에서 생성한 참조정보를 가지고 콜백 오브젝트의 메소드를 호출한다.
* 콜백은 클라이언트의 메소드에 있는 정보와 템플릿이 제공한 참조정보를 이용해 작업을 수행하고 그 결과를 다시 템플릿에 돌려준다.
* 패턴에 녹아있는 전략패턴과 수동 DI를 이해할 것!

###편리한 콜백의 재활용
* 콜백의 분리와 재활용 : 변하는것과 변하지 않는 것을 분리하고 변하지 않는건 유연하게 재활용할수있게 만든다.
* 콜백과 템플리스이 결합
* 파일한줄씩 읽어와 계산하는 계산기를 예로 들었다.

###TIP
* 고정된 작업흐름을 갖고있으면서 자주 반복되는 코드가 있다면
* 일단 메소드로 분리한후
* 그중 일부만을 바꿔서 사용해야한다면 인터페이스를 사이에 두고 전략패턴
* 바뀌는 부분이 한 어플리케이션 안에서 동시에 여러종류가 만들어진다면 템플릿/콜백 패턴

##정리
* JDBC와 같은 예외가 발생할 가능성이 있으며 공유 리소스의 반환이 필요한 코드는 반드시 try/catch/finally 블록으로 관리해야한다.
* 일정한 작업 흐름이 반복되면서 그중 일부 기능만 바뀌는 코드가 존재한다면 전략패턴을 적용해야한다. 바뀌지 않는 부분은 컨텍스트로, 바뀌는 부분은 전략으로 만들고 인터페이스를 통해 유연하게 전략을 변경할 수 있도록 구성한다.
* 같은 애플리케이션 안에서 여러 가지 종류의 전략을 다이내믹 하게 구성하고 사용해야 한다면 컨텍스트를 이용하는 클라이언트 메소드에서 직접 전략을 정의하고 제공하게 만든다.
* 컨텍스트가 하나 이상의 클라이언트 오브젝트에서 사용된다면 클래스를 분리해서 공유하도록 만든다.
* 컨텍스트는 별도의 빈으로 등록해서 DI받거나 클라이언트 클래스에서 직접 생성해서 사용한다. 클래스 내부에서 컨텍스트를 사용할 때 컨텍스트가 의존하는 외부의 오브젝트가 있다면 코드를 이용해서 직접 DI 해줄 수 있다.
* 단일 전략 메소드를 갖는 전략 패턴이면서 익명 내부 클래스를 사용해서 매번 전략을 새로 만들어서 사용하고, 컨텍스트 호출과 동시에 전략 DI를 수행하는 방식을 템플릿/콜백 패턴이라고 한다.
* 콜백의 코드에도 일정한 패턴이 반복된다면 콜백을 템플릿에 넣고 재활용 하는것이 편리하다.
* 템플릿과 콜백의 타입이 다양하게 바뀔 수 있다면 제네릭스를 이용한다.
* 스프링은 JDBC 코드 작성을 위해 JdbcTemplete를 기반으로 하는 다양한 템플릿과 콜백을 제공한다
* 템플릿은 한번에 하나 이상의 콜백을 사용할 수도 있고, 하나의 콜백을 여러 번 호출할 수도 있다.
* 템플릿/콜백을 설계할 때는 템플릿과 콜백 사이에 주고받는 정보에 관심을 둬야 한다.
